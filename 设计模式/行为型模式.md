在不同对象之间划分责任和算法的抽象化，通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互
- 类行为型模式：类的行为模式使用继承关系在几个类之间分配行为
- 对象行为型模式：对象行为模式使用对象的聚合关联关系来分配行为
## 职责链模式
链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并使请求沿着链传递
### 模式定义
让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求
### 模式结构
Handler：抽象处理者
ConcreteHandler：具体处理者
Client：客户类
![[Pasted image 20251202011400.png]]
### 模式分析
请求在链上传递，直到链上某一个对象处理此请求为止
### 模式优缺点
优点
- 降低耦合度
- 增加新的请求处理类方便
- 简化对象的互相连接
缺点
- 不能保证请求一定被接收
- 系统性能受到一定影响
### 模式适用环境
- 多个对象处理一个请求，具体哪个对象处理该请求由运行时刻自动确定
- 可动态指定一组对象处理请求
## 观察者模式
建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应
### 模式定义（一对多依赖关系）
每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图 （Model/View）模式、源-监听器（Source/Listener）模式或从属者 （Dependents）模式。观察者模式是一种对象行为型模式
### 模型结构
Subject：目标
ConcreteSubject：具体目标
Observer：观察者
ConcreteObserver：具体观察者
### 模式优缺点
优点
- 观察者实现表示层和数据逻辑层分离
- 在观察目标和观察者之间建立了一个抽象的耦合
- 支持广播通信
- 符合开闭原则
缺点
- 观察者和目标之间有循环依赖的话可能导致系统崩溃
- 没有相应机制让观察者指定所观察的目标对象怎么发生变化的
### 模式适用环境
- 一个对象改变导致多个对象改变
- 一个对象必须通知其他对象，并且不知道这些对象是谁
- 需要在系统中创建触发链 A 影响 B，B 影响 C
## 命令模式
将请求封装成一个对象，从而让我们可用不同不同的请求对客户端进行参数化
### 模式结构
- Command：抽象命令类
- ConcreteCommand：具体命令类
- Invoker：调用者
- Receiver：接收者
![[Pasted image 20251202103655.png]]
### 模式优缺点
优点
- 降低系统耦合度
- 新的命令很容易加进来
- 可以较为容易取设计一个命令队列和宏命令
缺点
- 导致系统有过多具体命令类
### 模式适用环境
- 请求调用者和请求接收者解耦
- 在不同时间指定请求、将请求排队
- 需要执行 undo 或者 redo 操作
- 执行宏命令                  
## 策略模式
定义一些独立的类来封装不同的算法，每个类封装一个具体的算法，每个封装的类称为策略，一般用一个抽象策略类做算法定义
### 模式结构
Context: 环境类
Strategy：抽象策略类
ConcreteStrategy：具体策略类
![[Pasted image 20251202110450.png]]
### 模式优缺点
优点
- 对开闭原则完美支持
- 提供管理算法族的方法
- 可以替换继承关系的方法
- 避免用多重条件转移语句
缺点
- 客户必须知道所有策略类
- 会产生很多策略
### 模式适用环境
- 系统有许多类，它们区别仅限于它们行为
- 需要动态地在几种算法选一种
- 一个对象有很多行为，如果不用恰当模式，只能用 if 语句实现
- 不喜欢客户端知道具体算法封装
## 状态模式
一个对象的行为取决于一个或者多个动态变化的属性，这样的属性叫状态，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象 (Objects for States)
### 模式结构
Context：环境类
State：抽象状态类
ConcreteState：具体状态类
![[Pasted image 20251202111635.png]]
### 模式优缺点
优点
- 封装了转换规则
- 枚举可能状态
- 方便新增状态
- 多个环境对象共享一个状态对象
缺点
- 增加系统类和对象个数
- 容易导致程序结构混乱
- 对开闭原则支持不太好
### 模式适用环境
- 行为依赖状态属性，根据状态改变行为
- 代码包含大量与对象状态有关的条件语句
## 模板方法模式
基于继承的代码复用基本技术，可以将相同代码放在父类中，将不同的方法放在不同子类
### 模式结构
AbstractClass：抽象类
ConcreteClass：具体子类
![[Pasted image 20251202122518.png]]
一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则给出算法的各个步骤，实现这些具体逻辑的方法称为基本方法，汇总起来称为模板方法

钩子方法用于控制要不要执行某个步骤
```
public abstract class Beverage {

    // 模板方法
    public final void makeDrink() {
        boilWater();
        brew();
        pourInCup();

        if (customerWantsCondiments()) { // 钩子
            addCondiments();
        }
    }

    private void boilWater() { System.out.println("烧开水"); }
    private void pourInCup() { System.out.println("倒入杯中"); }

    protected abstract void brew();
    protected abstract void addCondiments();

    // 钩子方法：默认返回 true
    protected boolean customerWantsCondiments() {
        return true;
    }
}

public class BlackCoffee extends Beverage {

    @Override
    protected void brew() {
        System.out.println("冲黑咖啡");
    }

    @Override
    protected void addCondiments() {
        System.out.println("（本应加糖/牛奶）");
    }

    @Override
    protected boolean customerWantsCondiments() {
        // 钩子方法：这个饮料不加调料
        return false;
    }
}
//返回false就会跳过钩子方法

```

### 模板方法优缺点
优点
- 在一个类中形式化定义算法，由子类实现细节处理
- 代码复用技术
- 符合开闭原则
缺点
- 每个不同实现都需要定义一个子类，会导致类的个数增加
### 适用环境
1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现
2. 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现
3. 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复
## 解释器模式
定义语言的文法，建立一个解释器来解释该语言中的句子
### 模式结构
AbstractExpression：抽象表达式
TerminalExpression：终结符表达式
NonterminalExpression：非终结符表达式
Context：环境类
Client：客户类

### 模式优缺点
优点
- 易于改变和扩展文法
- 易于实现文法
- 增加了新的解释表达式的方式
缺点
- 对于复杂文法难以维护
- 执行效率低
- 应用场景有限
