创建型模式对类的实例化过程进行了抽象，能将软件模块中对象的创建和对象的使用分离，使系统更符合单一职责原则
## 一、简单工厂模式
- 又称静态工厂方法模式，根据参数返回不同类的实例
- 该模式专门定义一个类来负责创建其他类的实例，被创建的实例通常有共同父亲
### 模式结构
- Factory：工厂角色
- Product：抽象产品角色
- ConcreteProduct：具体产品角色
![[Pasted image 20251201111322.png]]
### 优缺点
缺点
- 工厂集成了所有创建逻辑，不能受影响
- 增加系统类的个数，增加系统复杂度
- 拓展时需要修改工厂逻辑
- 静态工厂方法，工厂角色无法形成基于继承的等级结构
### 适用环境
1. 工厂类负责创建的对象比较少
2. 客户端只知道传入工厂类的参数，不需要关心具体实现
## 二、工厂方法模式
工厂父类负责定义产品对象的公共接口，工厂子类负责生成具体的产品对象
![[Pasted image 20251201112046.png]]
### 模式结构
1. 抽象产品
2. 具体产品
3. 抽象工厂：声明工厂方法，用于返回一个产品
4. 具体工厂：返回具体产品类的实例
### 优缺点
优点
- 用户只用关心产品对应工厂，无需关心生产细节
- 加入新产品无需修改抽象工厂和抽象产品提供的接口，只需要添加一个具体工厂或者具体产品即可
缺点
- 编写具体产品类需要添加具体工厂，成对增加类的个数
- 引入的抽象层增加了系统的抽象性和理解难度
## 适用环境
- 一个类不知道它所需要的对象的类
- 一个类通过其子类来指定创建哪个对象
- 客户端在使用时无需关心是哪个工厂子类创建产品子类，需要时动态指定
## 三、抽象工厂模式

每个工厂只生产一类产品，可能会导致系统中存在大量工厂类，增加系统开销
### 模式动机
- 产品等级结构：产品的继承结构
- 产品族：由同一个工厂生产的，位于不同产品等级结构的一组产品
![[Pasted image 20251201131644.png]]
### 模式优缺点
**优点**
- 隔离了具体类生成，实现高内聚低耦合
- 能保证客户端始终使用一个产品族
- 增加新的工厂和产品族很方便，符合开闭原则
**缺点**
- 添加新的产品对象需要对抽象工厂及其子类修改
- 开闭原则倾斜性（增加新的工厂和产品族容易，但是增加新的产品等级结构麻烦）
### 模式适用环境
1. 不依赖于产品类实例的创建组合等细节
2. 多于一个产品族
3. 所有产品以同样的接口实现
## 四、建造者模式
系统中存在一些复杂对象拥有多个组成部分，建造者模式可以将部件和组装过程分开，一步一步创建一个复杂对象
### 模式定义
- 将一个复杂对象的构建与表示分离，相当于同样的构建过程可以创建不同的表示
- 建造者模式是一步一步创建复杂对象
### 模式结构
- 抽象建造者
- 具体建造者
- 指挥者
- 产品角色
![[Pasted image 20251201135322.png]]
### 模式优缺点
优点
- 不用知道产品内部细节
- 使用不同建造者可以得到不同对象
- 可以更精细控制创建过程
- 新增具体建造者无需修改原有类库代码
缺点
- 建造者模式的产品一般有较多共同点，产品之间差异大不适合用此模式
- 如果产品内部变化复杂，需要有很多具体建造者，系统会臃肿
### 使用环境
1. 需要生成复杂的内部结构
2. 产品对象的属性互相依赖
3. 对象的创建过程独立于创建该对象的类
4. 隔离复杂对象创建和使用
## 五、原型模式
有些对象创建过程复杂，又需要频繁创建
原型模式是用原型实例指定创建对象的种类，并且能通过复制这些原型创建新的对象
### 模式结构
- 抽象原型类
- 具体原型类
- 客户类
![[Pasted image 20251201142036.png]]
必须得实现标识接口 Cloneable
### 模式分析
- 对任何对象 X，都有 X.clone () != X
- X.clone (). getClass () == X.getClass ()
- X.clone (). equals (x) 成立
![[Pasted image 20251201165543.png]]
#### 浅克隆
浅克隆对象基本字段可以修改，比如类型时 String 这些的
如果是引用对象类型就不能修改，一修改所有都会变
#### 深克隆
![[Pasted image 20251201171506.png]]
### 模式优缺点
优点
- 简化对象创建过程，通过已有实例可以提高新实例创建效率
- 动态增加或减少产品类
- 提供简化的创建结构
- 使用深克隆可以保存对象的状态
缺点
- 需要为每一个类配备一个克隆方法
- 实现深克隆时需要完成较为复杂的代码
### 模式适用环境
1. 创建新对象成本大
2. 如果系统要保存对象状态，而对象状态变化很小
3. 需要避免使用分层次的工厂来创建分层次的对象
## 六、单例模式
### 模式动机
- 定义一个全局变量可以确保对象随时可以被访问，但不能防止我们实例化多个对象
- 让类自身负责保存它的唯一实例
### 模式定义
- 单例模式：确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例
#### 要点
1. 某个类只能由一个实例
2. 它必须自行创建这个实例
3. 它必须向整个系统提供这个实例
![[Pasted image 20251201173319.png]]
![[Pasted image 20251201173357.png]]
### 模式优缺点
优点
- 对唯一实例的受控访问
- 节约系统资源
- 允许可变数目的实例
缺点
- 没有抽象层，扩展难度大
- 单例类职责过重
- 滥用单例可能带来负面问题
### 模式适用环境
1. 系统只需要一个实例对象
2. 只允许一个公共访问点
### 饿汉式和懒汉式单例模式
- 饿汉式：类加载时立即创建，天生线程安全，性能最好，可能浪费资源
- 懒汉式：第一次调用才创建，不安全，性能略低，写法复杂