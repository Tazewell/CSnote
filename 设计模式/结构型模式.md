结构型模式描述如何将类或者对象结合在一起形成更大的结构
## 结构型模式概述
- 类结构型模式
- 对象结构型模式
1. 类结构型模式关心类的组合，一般只存在继承关系和实现关系
2. 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法，根据"**合成复用原则**"，系统尽量使用关联关系代替继承关系，大部分结构型模式都是对象结构型模式
## 适配器模式
### 模式动机
适配器的实现就是把客户类的请求转化为适配者的相应接口的调用
### 模式定义
将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类一起工作，其别名为包装器（Wrapper），既可以作为类结构模式，也可以作为对象结构型模式
### 模式结构
- 目标抽象类
- 适配器类
- 适配者类（Adaptee）
- 客户端
![[Pasted image 20251201180720.png]]
### 模式优缺点
优点
- 将目标类和适配者类解耦，无需修改原有代码
- 增加了类的透明性和复用性
- 灵活性和扩展性好
类适配器优点：可以在适配器类中置换一些适配者的方法，使得适配器更灵活
类适配器缺点：对于不支持多重继承的语言，一次最多只能适配一个适配者类，且目标抽象类只能为抽象类，有局限性

对象适配器优点：可以把多个不同的适配者配到同一个目标
对象适配器缺点：想置换适配者类的方法不容易
### 模式适用环境
1. 需要使用现有类，而这些接口不符合系统的需要
2. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的类一起工作
## 组合模式
将**容器对象**和**叶子对象**进行递归组合，使用户无需对他们进行区分，可以一致对待容器对象和叶子对象
### 模式定义
组合多个对象形成树状结构，组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性
### 模式结构
- Component: 抽象组件
- Leaf: 叶子组件
- Composite: 容器构件
- Client: 客户类
![[Pasted image 20251201211235.png]]
### 模式优缺点
优点
- 清楚定义分层次的复杂对象
- 客户端可以一致的使用组合结构或其单个对象
- 更容易在组合体内加入对象构件
缺点
- 设计更加抽象
- 新增构件时很难对容器中的构件类型进行限制
### 模式适用环境
- 需要表示一个对象整体或部分层次，希望通过一种方式忽略整体与部分的差异，一致对待
- 客户端可以针对抽象构件编程
- 对象结构动态的，且复杂程度不一样，但客户端需要一致处理它们
## 装饰模式
以对客户透明的方式动态给一个对象加上更多的责任，在不需要创造更多子类情况下，将对象的功能加以拓展
### 模式定义
动态地给一个对象增加一些额外地职责，别名为包装器（Wrapper）
### 模式结构
Component: 抽象构件
ConcreateComponent: 具体构件
Decorator: 抽象装饰类
ConcreateDecorator: 具体装饰类
![[Pasted image 20251201213340.png]]
### 模式优缺点
优点
- 装饰模式提供比继承更多地灵活性
- 通过动态方式扩展一个对象地功能
- 具体构建类和具体装饰类可以独立变化
缺点
- 产生很多小对象
- 装饰模式比继承更容易出错，排错需要逐级排查
### 模式适用环境
1. 不影响其他对象的情况下，动态透明的方式给单个对象添加职责
2. 需要动态添加功能，且功能可以被撤销
3. 不能用继承对系统进行扩充（**final 类不能继承**）或者用继承不利于维护的时候
## 外观模式
引入外观角色后，用户只需要直接和外观角色交互，用户与子系统之间复杂关系有外观角色来实现
### 模式定义
外部与一个子系统通信要通过一个外观对象进行，为子系统提供一个一致的界面
### 模式结构
- Facade：外观角色
- SubSystem：子系统角色
![[Pasted image 20251201215244.png]]
![[Pasted image 20251201215523.png]]
### 模式优缺点
优点
- 对客户屏蔽子系统，减少客户处理
- 实现了子系统与客户的松耦合
- 提供统一入口，不会影响用户直接适用子类
缺点
- 不能很好限制客户适用子系统
- 不引入抽象外观类的情况下，新增子系统需要修改外观类源码，违背了开闭原则
### 模式适用环境
1. 为一个复杂子系统提供简单接口时可以使用外观模式
2. 客户程序与多个子系统之间存在很大依赖性
违反开闭原则可以引入抽象外观类解决 ![[Pasted image 20251201220856.png]]
## 享元模式
享元模式中可以共享的相同内容称为内部状态，不能贡献的称为外部状态
### 模式定义
运用共享技术有效支持细粒度对象的复用，这些对象很相似，变化很小
### 模式结构
Flyweight: 抽象享元类
ConcreteFlyweight: 具体享元类
UnsharedConcreteFlyweight: 非共享具体享元类
FlyweightFactory: 享元工厂类
### 分析
享元工厂类提供一个储存享元对象的享元池，如果享元池不存在，则新建一个享元对象给用户，并且享元池新增该对象
### 模式优缺点
优点
- 极大减少内存中对象的数量
- 外部状态保持独立，不会影响内部状态，使得享元对象可以在不同的环境中被共享
缺点
- 由于需要分离外部状态和内部状态，使得系统更复杂
- 为了使对象共享，需要将享元对象的状态外部化，读取时间长
### 模式适用环境
1. 一个系统有大量相似对象
2. 对象大部分状态可以外部化
3. 多次重复使用享元对象时才值得使用享元模式
## 代理模式
通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，通过引入代理对象来简洁访问一个对象
### 模式定义
给某个对象提供一个代理，并由代理对象控制原对象的引用
### 模式结构
- Subject：抽象主题角色
- Proxy：代理主题角色
- RealSubject：真实主题角色![[Pasted image 20251202004707.png]]
### 模式优缺点
优点
- 能协调调用者和被调用者
- 远程代理使客户端可以访问远程机器上的对象
- 虚拟代理可以使用小对象代表大对象，减少系统资源浪费（比如图片代理）
- 保护代理可以控制权限
缺点
- 代理模式可能请求变慢
- 实现代理模式需要额外的工作，非常复杂
### 模式适用环境
1. 远程代理
2. 虚拟代理
3. Copy-on-Write 代理：把克隆操作延迟到只有在客户端真正需要时才执行
4. 保护代理
5. 缓冲代理
6. 防火墙代理
7. 同步化代理：使几个用户可以同时使用一个对象没有冲突
8. 智能引用代理

