# 第一章：概述
## 软件工程简介
**软件工程**
**$Software=Program+Data+Document$**
程序：按照事先设计的功能和性能要求执行的指令序列
数据：使程序能正常操纵信息的数据结构
文档：与程序开发、维护和使用有关的图文材料

**软件发展存在的问题**
1. 进度难以控制
2. 维护非常困难

**解决方法**
把系统的、规范的、可度量的方法应用于软件开发、运行和维护过程，即把工业思想应用于软件

## 软件开发方法
### **面向过程**
以过程为中心的编程思想，重点关注数据结构、算法和执行步骤，过程难以重用
分析、设计、实现上很难统一，要进行概念转换

**开发思想**
现实世界被映射为**功能**（函数）的集合--->程序=算法+数据结构
数据结构发生变化，算法也发生变化
### 面向对象
把相关数据和方法组织成一个整体，从高层次建模，更贴近事物自然运行
->程序=n* （对象+消息）
对象 1={算法 1+数据结构 1}
对象 2={算法 2+数据结构 2}

**封装性**
有选择地数据隐藏、防止以外数据破坏保证安全性、更易于隔离和修复错误

**区别**：

| 面向过程     | 面向对象    |
| -------- | ------- |
| 1. 系统级软件 | 1. 用户软件 |
| 2. 数据库   | 2. 企业应用 |
| 3. 操作系统  | 3. 游戏   |
| 4. 协议    | 4. 电商   |
**面向对象**：把构成问题事务分解成对象，为了描述某个事物在整个解决问题过程中地行为
**面向过程**：解析出解决问题地步骤，然后每个步骤对应一个函数，然后再依次调用
## 面向对象方法 OOSD
 **解决思路**
 从现实世界中地客观对象入手，运用人类地自然思维方式构造软件系统，是运用对象、类、继承、封装、聚合、消息发送、多态性等概念构造系统地方法
 **对象是功能抽象和数据抽象的统一**
### 主要优点
使得客观世界和计算机世界语言的鸿沟变窄
（面向对象语言）能较为直观的反映客观世界本来面目，开发人员能用人类认识事物所用的思维方式来开发
（高级语言）高级语言用有形象意义的数据描述具体事务，便于体系客观事物结构和逻辑涵义
（汇编语言）符号指令等，稍微符合人类形象思维，抽象层次太低，仍需考虑大量机器细节
（机器语言）01 构成，没有丝毫形象意义，离人类思维最远
### OOSD 组成
1. OOA：面向对象的分析
2. OOD：面向对象的设计
3. OOP：面向对象的程序设计
![[Pasted image 20251226212238.png]]

### 对象
1. 客观世界里的任何实体
2. 软件中的对象是与应用问题有关联的事物
3. 对象是一个封装数据属性和操作行为的实体
### 类
1. 类是对一类具有相同特征的对象的描述: 类共享属性、操作、关系以及用来描述大对象集合的语义，并定义每个对象的结构和行为
2. 类封装了数据和行为

### 抽象
1. 抽象是抽取对问题域有帮助的对象属性和行为
2. 抽象是从众多事物中抽取共同的、本质的特征
3. 问题域不同、抽象程度不同，抽象结果也不同

### 继承
子类自动获得父类中定义的数据、方法和关系，并可以添加新的成员机制
- 起始类称为基类、超类、父类或者泛化类，继承类称为派生类、子类或者特化类
- 继承可以提高软件复用性
- 继承具有传递性
- 继承表示类之间有层次关系
- 继承可以分单继承（一个父类）和多继承（多个父类）

### 接口
- 接口是一组没有相应方法实现的操作，只说了函数该做什么，没明确怎么做
- 一般只包含操作，不包含属性
- 一个接口可以被多个类实现，一个类可以继承多个接口

### 多态
同一操作作用于不同对象有不同结果
比如 $cry()$ 用在猫和狗的类里，实现方式就不一样

**多态性的实现**
1. 通过接口实现
2. 通过抽象类实现

**优势**
1. 面向对象技术利用多态提供动态行为特征，适应变更
2. 增加了面向对象软件系统的灵活性
3. 减少信息冗余
4. 提高软件可重用性和可扩展性

### 消息
- 每个对象都至少与另外一个对象联系
- 孤立的对象是无用的
- 对象之间通过互相发送消息进行协作的

# 第二章：软件建模与 UML
## 软件建模
**模型**：对现实世界的简化抽象
1. 帮我们对系统进行可视化
2. 运行详细说明系统结构和行为
3. 给出指导构造系统的模板
4. 对我们做的决策文档化

**软件建模**：把软件系统中人们关心的各个部分用模型的方式表达出来，帮助开发人员对系统的**行为**和**结构**进行有效说明和可视化，指导软件系统构造

**软件建模的关键是抽象**

### 软件建模的作用
1. 可视化系统
2. 允许开发人员定制系统结构或行为，并将其联系
3. 提供指导性的构造系统模板
4. 揭示简化和复用的机会
5. 记录开发人员决策
6. 测试能早期修正缺陷
7. 降低软件开发复杂度

### 特征
1. 准确性
2. 可解释性
3. 一致性
4. 可修改性

### 软件建模的原则
1. 准确的原则：反映真实情况
2. 分层的原则：要有不同模型
3. 分治的原则：不能用一个模型反映整个系统任何侧面（软件是复杂的）
4. 标准的原则：模型在一定程度上通用的

## UML 概述
系统建模需要一种规范的语言进行描述，称为**建模语言**，使用标准的图形表示法建模，也称为**可视化建模语言**
最大特点：图形化、可视化
### UML
为面向对象提供统一、标准、可视化建模语言，描述以**用例为驱动**、以**体系结构为中心**的软件设计的全过程

UML 统一的普遍意义是形成标准：
- 开发生命周期
- 应用领域
- 实现语言和平台
- 开发过程
- 自身内部概念

### UML 的建模适合的场景
现实世界--(建模)-->业务模型--(概念)-->概念模型--(设计)-->设计模型

## UML 组成
### UML 的构造块
- 事物
	- 结构事物
	- 行为事物
	- 分组事物
	- 注释事物
- 关系
	- 依赖：A 用到了 B
	- 关联：A 知道 B 的属性和方法
	- 泛化：继承
	- 实现
- 图
	- 结构图
		- 类图
		- 对象图
		- 构建图
		- 部署图
	- 行为图
		- 序列图
		- 协作图
		- 状态图
		- 活动图
		- 用例图
### 结构事物
UML 静态部分，描述概念或者物理元素
类：具有相同属性相同操作相同关系相同语义的对象的描述
接口：元素外部可见行为
协作：一组事物相互作用
用例：一组动作的序列集合
构件：系统中物理存在可替换的部件（连接数据库）
节点：运行时存在的物理元素

### 行为事物
UML 动态部分，描述跨越空间和时间的行为
交互：实现某功能的一组构件事物之间的消息的集合，涉及消息、动作序列
状态机：描述事物或交互在生命周期内响应事件所经历的状态序列
活动：计算过程执行的步骤

### 分组事物
描述事物的组织结构

### 注释事物
UML 模型的解释部分，对模型中元素解释说明

## UML 的图
### 用例图
参与者的外部用户所能观察到的系统功能的模型图（多用于静态建模阶段）----**业务建模**和**需求建模**
**用例图元素**
![[Pasted image 20251227100414.png]]

**图书馆系统用例图**
![[Pasted image 20251227100505.png]]

### 类图
反映类的结构（属性、操作），描述了软件系统的结构，是一种静态建模方法
主要包含从上到下三个部分：**类名、属性、操作**
- 可见性：$-$ 代表 $private$、$+$ 代表 $public$、$#$ 代表 $protected$
- 操作名称：斜体为抽象操作
- 类名：斜体为抽象类

### 对象图
对象图展示了一组对象以及它们之间的关系，描述了所建立实例的静态快照，由于对象存在生命周期，因此只能反映系统运行某时间段内的对象状态和关系
![[Pasted image 20251227101312.png]]

### 顺序图
用来表示用例中的行为顺序，当执行一个用例行为时，顺序图每条消息对应了一个类操作或者状态机中引起转换的事件
**浏览方式**：从上到下查看对象间交换的消息

**ATM 机取钱交互**
![[Pasted image 20251227101627.png]]

### 协作图
交互图，强调的是发送和接收消息的对象之间的组织结构，说明系统的动态情况，可以表示类操作的实现

**ATM 机取钱协作**
![[Pasted image 20251227101847.png]]

### 活动图
描述系统的动态行为，包括活动状态（业务用例的一个执行步骤或一个操作），类似于流程图
活动图主要用于业务建模时，详述业务用例，描述一项业务执行过程
![[Pasted image 20251227102408.png]]

### 状态图
用于利用状态和事件描述对象本身的动态特性（行为），仅用于具有多个明确状态且这些状态会影响和改变其行为的类

**例如**：一台洗衣机状态有浸泡、洗涤、漂洗、脱水、开机、关机
![[Pasted image 20251227102653.png]]

### 组件图
组件图用来描述组件、接口以及它们之间关系，是系统的物理实现图，展示了系统的实现视图

**ATM 系统组件图**
![[Pasted image 20251227103102.png]]

### 部署图（配置图）
节点是一组物理运行资源，如计算机、设备或者存储器，部署图显示软件单元、可执行组件在哪个节点运行

**ATM 部署图**
![[Pasted image 20251227103313.png]]
### 包图
多个类构成了一个子系统，应该放到一个包中 ![[Pasted image 20251227103438.png]]

**UML 中几个图的关系**
![[Pasted image 20251227104331.png]]

## UML 建模流程
业务阶段-->用例建模-->用例分析-->设计阶段-->代码实现阶段
![[Pasted image 20251227104607.png]]

# 第三章：用例建模
### 理解需求
- 业务需求：反映机构、客户对系统、产品的目标要求
- 用户需求：描述用户使用产品需要完成什么任务以及怎么完成（用户访谈调研完成）
- 系统需求：从系统角度触发说明软件需求

## 用例图
### 用例的作用
作为整个系统开发过程的开发依据，指导和驱动其他模型，用例图多用于**业务建模**和**需求建模**

从客户角度来描述系统功能，只关心所能提供的服务，不需要了解系统的内部结构和设计细节
- 参与者
- 用例
- 关系

### 参与者
系统外部与系统直接交互的事物，参与一个或多个用例

**参与者种类**
1. 与系统直接交互的人
2. 与系统直接交互的其他系统（计算机外部设备、数据库、软件系统）
3. 一些可以运行的进程、时间、设备

比如：计算网络系统参与者可以是系统管理员、数据库管理员、网络打印机、可运行进程，如果定期备份数据库，此时的时间作为参与者

- 主要参与者：启动用例，系统必须响应主要参与者
- 次要参与者：可以参与到用例中
至少有一个参与者必须从用例中获得价值，通常这就是主要参与者

**参与者之间的关系**
1. 泛化关系：继承
2. 关联关系：一个参与者可以访问多个用例，一个用例可以被多个参与者访问

### 用例
用例是对一个参与者使用系统的一项功能时所进行的交互过程的一个文字描述序列，是参与者可以感受到的系统服务或功能单元

比如：图书馆中的用例有借书、还书、查找图书、借书证管理等

**用例的特征**
- 站在系统外部，看到系统的功能
- 总是被参与者启动
- 描述一个功能的交互场景
- 本质是一种功能分解技术
- 交互过程描述种可以发现类

#### **用例之间的关系**
**包含关系**
描述的是一个用例需要的功能被另外一个用例定义，基用例把被包含的用例行为作为自身行为的一部分
- 箭头方向由基用例指向被包含的用例，被包含的用例如果不存在了，基用例就不完整了
- 执行基用例时，每次都必须调用被包含的用例
- 被包含的用例也可以单独执行
![[Pasted image 20251227134856.png]]

**使用时机：**
1. 复用：如果两个以上用例有大量一致的功能，可以将一致的功能抽取到另一个用例，其他用例和这个用例建立包含关系
2. 功能分解：一个用例的功能太复杂时，将其功能分解为小功能用例

#### 扩展关系
基用例本身是一个完整用例，可以单独执行，执行基用例时，扩展用例不是每次都被执行
**扩展用例本身不是完整独立的用例，无法单独执行，必须依赖基用例**
![[Pasted image 20251227135645.png]]

UML 中提供了扩展点来为基用例扩展新行为，基用例中扩展点给出条件满足，则扩展用例将被执行

**区分包含关系和扩展关系**
包含用例必然被执行，扩展用例条件被执行

#### 泛化关系
同一业务目的不同技术实现
**用例之间可以泛化，参与者之间可以泛化**
父用例常常是抽象用例 ![[Pasted image 20251227140933.png]]

### 用例描述
针对每个用例，都应该有一个用例规约文档与之对应，文档描述参与者与系统交互实现用例功能的事件流
- 用例名称：表面用例用途
- 标识符（选）：唯一
- 参与者（选）：与此用例相关的参与者列表
- 简要说明：对用例说明，描述作用
- 前置条件：条件列表，描述用例之前系统必须满足条件，比如借书前置条件：借书证合法
- 后置条件：后置条件在用例成功后得到满足，它提供系统的部分描述，比如用例结束后系统处于什么状态
- 扩展点：写出扩展用例在什么条件下使用
- 基本事件流（主事件流）：描述正常进行时用例的工作方式
- 其他事件流（扩展事件、错误事件）：发生异常情况下的步骤
![[Pasted image 20251227143252.png]]

## 用例建模
### 用例建模流程
1. 获取原始需求：涉众（问卷、访谈、开会、原型...）
2. 开发一个可以理解的需求
	1. 识别参与者（在**系统之外**，透过系统边界与系统进行有意义的交互的**任何事物**，不在数量）----**责任类似或重叠，泛化出一个抽象执行者**
	2. 识别用例（执行动作后会生成特定执行者可见的**价值结果**）--要以用户观点而非系统观点 ![[Pasted image 20251227144312.png]]
		参与者视角：（状语）动词+（定语）宾语 ![[Pasted image 20251227144507.png]]
		------------------------------------------------------------------------------------------
	3. 绘制用例图 ![[Pasted image 20251227144541.png]]
3. 详细、完整描述需求
	1. 编写用例文档 (上述的文字方法或者活动图)
4. 重构用例模型
	1. 识别用例间关系
	2. 对用例进行分包和分级


## 用例建模常见问题
1. 参与者通过其他参与者使用系统的用例
2. 用例的包含关系和扩展关系区别
3. 系统边界
4. 用例模型的层次
5. 不同层次的用例模型的一致性

用例是因，功能是果
用例是目标，不是过程，是按照价值分解