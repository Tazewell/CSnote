# 第一章：概述
## 软件工程简介
**软件工程**
**$Software=Program+Data+Document$**
程序：按照事先设计的功能和性能要求执行的指令序列
数据：使程序能正常操纵信息的数据结构
文档：与程序开发、维护和使用有关的图文材料

**软件发展存在的问题**
1. 进度难以控制
2. 维护非常困难

**解决方法**
把系统的、规范的、可度量的方法应用于软件开发、运行和维护过程，即把工业思想应用于软件

## 软件开发方法
### **面向过程**
以过程为中心的编程思想，重点关注数据结构、算法和执行步骤，过程难以重用
分析、设计、实现上很难统一，要进行概念转换

**开发思想**
现实世界被映射为**功能**（函数）的集合--->程序=算法+数据结构
数据结构发生变化，算法也发生变化
### 面向对象
把相关数据和方法组织成一个整体，从高层次建模，更贴近事物自然运行
->程序=n* （对象+消息）
对象 1={算法 1+数据结构 1}
对象 2={算法 2+数据结构 2}

**封装性**
有选择地数据隐藏、防止以外数据破坏保证安全性、更易于隔离和修复错误

**区别**：

| 面向过程     | 面向对象    |
| -------- | ------- |
| 1. 系统级软件 | 1. 用户软件 |
| 2. 数据库   | 2. 企业应用 |
| 3. 操作系统  | 3. 游戏   |
| 4. 协议    | 4. 电商   |
**面向对象**：把构成问题事务分解成对象，为了描述某个事物在整个解决问题过程中地行为
**面向过程**：解析出解决问题地步骤，然后每个步骤对应一个函数，然后再依次调用
## 面向对象方法 OOSD
 **解决思路**
 从现实世界中地客观对象入手，运用人类地自然思维方式构造软件系统，是运用对象、类、继承、封装、聚合、消息发送、多态性等概念构造系统地方法
 **对象是功能抽象和数据抽象的统一**
### 主要优点
使得客观世界和计算机世界语言的鸿沟变窄
（面向对象语言）能较为直观的反映客观世界本来面目，开发人员能用人类认识事物所用的思维方式来开发
（高级语言）高级语言用有形象意义的数据描述具体事务，便于体系客观事物结构和逻辑涵义
（汇编语言）符号指令等，稍微符合人类形象思维，抽象层次太低，仍需考虑大量机器细节
（机器语言）01 构成，没有丝毫形象意义，离人类思维最远
### OOSD 组成
1. OOA：面向对象的分析
2. OOD：面向对象的设计
3. OOP：面向对象的程序设计
![[Pasted image 20251226212238.png]]

### 对象
1. 客观世界里的任何实体
2. 软件中的对象是与应用问题有关联的事物
3. 对象是一个封装数据属性和操作行为的实体
### 类
1. 类是对一类具有相同特征的对象的描述: 类共享属性、操作、关系以及用来描述大对象集合的语义，并定义每个对象的结构和行为
2. 类封装了数据和行为

### 抽象
1. 抽象是抽取对问题域有帮助的对象属性和行为
2. 抽象是从众多事物中抽取共同的、本质的特征
3. 问题域不同、抽象程度不同，抽象结果也不同

### 继承
子类自动获得父类中定义的数据、方法和关系，并可以添加新的成员机制
- 起始类称为基类、超类、父类或者泛化类，继承类称为派生类、子类或者特化类
- 继承可以提高软件复用性
- 继承具有传递性
- 继承表示类之间有层次关系
- 继承可以分单继承（一个父类）和多继承（多个父类）

### 接口
- 接口是一组没有相应方法实现的操作，只说了函数该做什么，没明确怎么做
- 一般只包含操作，不包含属性
- 一个接口可以被多个类实现，一个类可以继承多个接口

### 多态
同一操作作用于不同对象有不同结果
比如 $cry()$ 用在猫和狗的类里，实现方式就不一样

**多态性的实现**
1. 通过接口实现
2. 通过抽象类实现

**优势**
1. 面向对象技术利用多态提供动态行为特征，适应变更
2. 增加了面向对象软件系统的灵活性
3. 减少信息冗余
4. 提高软件可重用性和可扩展性

### 消息
- 每个对象都至少与另外一个对象联系
- 孤立的对象是无用的
- 对象之间通过互相发送消息进行协作的

# 第二章：软件建模与 UML
## 软件建模
**模型**：对现实世界的简化抽象
1. 帮我们对系统进行可视化
2. 运行详细说明系统结构和行为
3. 给出指导构造系统的模板
4. 对我们做的决策文档化

**软件建模**：把软件系统中人们关心的各个部分用模型的方式表达出来，帮助开发人员对系统的**行为**和**结构**进行有效说明和可视化，指导软件系统构造

**软件建模的关键是抽象**

### 软件建模的作用
1. 可视化系统
2. 允许开发人员定制系统结构或行为，并将其联系
3. 提供指导性的构造系统模板
4. 揭示简化和复用的机会
5. 记录开发人员决策
6. 测试能早期修正缺陷
7. 降低软件开发复杂度

### 特征
1. 准确性
2. 可解释性
3. 一致性
4. 可修改性

### 软件建模的原则
1. 准确的原则：反映真实情况
2. 分层的原则：要有不同模型
3. 分治的原则：不能用一个模型反映整个系统任何侧面（软件是复杂的）
4. 标准的原则：模型在一定程度上通用的

## UML 概述
系统建模需要一种规范的语言进行描述，称为**建模语言**，使用标准的图形表示法建模，也称为**可视化建模语言**
最大特点：图形化、可视化
### UML
为面向对象提供统一、标准、可视化建模语言，描述以**用例为驱动**、以**体系结构为中心**的软件设计的全过程

UML 统一的普遍意义是形成标准：
- 开发生命周期
- 应用领域
- 实现语言和平台
- 开发过程
- 自身内部概念

### UML 的建模适合的场景
现实世界--(建模)-->业务模型--(概念)-->概念模型--(设计)-->设计模型

## UML 组成
### UML 的构造块
- 事物
	- 结构事物
	- 行为事物
	- 分组事物
	- 注释事物
- 关系
	- 依赖：A 用到了 B
	- 关联：A 知道 B 的属性和方法
	- 泛化：继承
	- 实现
- 图
	- 结构图
		- 类图
		- 对象图
		- 构建图
		- 部署图
	- 行为图
		- 序列图
		- 协作图
		- 状态图
		- 活动图
		- 用例图
### 结构事物
UML 静态部分，描述概念或者物理元素
类：具有相同属性相同操作相同关系相同语义的对象的描述
接口：元素外部可见行为
协作：一组事物相互作用
用例：一组动作的序列集合
构件：系统中物理存在可替换的部件（连接数据库）
节点：运行时存在的物理元素

### 行为事物
UML 动态部分，描述跨越空间和时间的行为
交互：实现某功能的一组构件事物之间的消息的集合，涉及消息、动作序列
状态机：描述事物或交互在生命周期内响应事件所经历的状态序列
活动：计算过程执行的步骤

### 分组事物
描述事物的组织结构

### 注释事物
UML 模型的解释部分，对模型中元素解释说明

## UML 的图
### 用例图
参与者的外部用户所能观察到的系统功能的模型图（多用于静态建模阶段）----**业务建模**和**需求建模**
**用例图元素**
![[Pasted image 20251227100414.png]]

**图书馆系统用例图**
![[Pasted image 20251227100505.png]]

### 类图
反映类的结构（属性、操作），描述了软件系统的结构，是一种静态建模方法
主要包含从上到下三个部分：**类名、属性、操作**
- 可见性：$-$ 代表 $private$、$+$ 代表 $public$、$#$ 代表 $protected$
- 操作名称：斜体为抽象操作
- 类名：斜体为抽象类

### 对象图
对象图展示了一组对象以及它们之间的关系，描述了所建立实例的静态快照，由于对象存在生命周期，因此只能反映系统运行某时间段内的对象状态和关系
![[Pasted image 20251227101312.png]]

### 顺序图
用来表示用例中的行为顺序，当执行一个用例行为时，顺序图每条消息对应了一个类操作或者状态机中引起转换的事件
**浏览方式**：从上到下查看对象间交换的消息

**ATM 机取钱交互**
![[Pasted image 20251227101627.png]]

### 协作图
交互图，强调的是发送和接收消息的对象之间的组织结构，说明系统的动态情况，可以表示类操作的实现

**ATM 机取钱协作**
![[Pasted image 20251227101847.png]]

### 活动图
描述系统的动态行为，包括活动状态（业务用例的一个执行步骤或一个操作），类似于流程图
活动图主要用于业务建模时，详述业务用例，描述一项业务执行过程
![[Pasted image 20251227102408.png]]

### 状态图
用于利用状态和事件描述对象本身的动态特性（行为），仅用于具有多个明确状态且这些状态会影响和改变其行为的类

**例如**：一台洗衣机状态有浸泡、洗涤、漂洗、脱水、开机、关机
![[Pasted image 20251227102653.png]]

### 组件图
组件图用来描述组件、接口以及它们之间关系，是系统的物理实现图，展示了系统的实现视图

**ATM 系统组件图**
![[Pasted image 20251227103102.png]]

### 部署图（配置图）
节点是一组物理运行资源，如计算机、设备或者存储器，部署图显示软件单元、可执行组件在哪个节点运行

**ATM 部署图**
![[Pasted image 20251227103313.png]]
### 包图
多个类构成了一个子系统，应该放到一个包中 ![[Pasted image 20251227103438.png]]

**UML 中几个图的关系**
![[Pasted image 20251227104331.png]]

## UML 建模流程
业务阶段-->用例建模-->用例分析-->设计阶段-->代码实现阶段
![[Pasted image 20251227104607.png]]

# 第三章：用例建模
### 理解需求
- 业务需求：反映机构、客户对系统、产品的目标要求
- 用户需求：描述用户使用产品需要完成什么任务以及怎么完成（用户访谈调研完成）
- 系统需求：从系统角度触发说明软件需求

## 用例图
### 用例的作用
作为整个系统开发过程的开发依据，指导和驱动其他模型，用例图多用于**业务建模**和**需求建模**

从客户角度来描述系统功能，只关心所能提供的服务，不需要了解系统的内部结构和设计细节
- 参与者
- 用例
- 关系

### 参与者
系统外部与系统直接交互的事物，参与一个或多个用例

**参与者种类**
1. 与系统直接交互的人
2. 与系统直接交互的其他系统（计算机外部设备、数据库、软件系统）
3. 一些可以运行的进程、时间、设备

比如：计算网络系统参与者可以是系统管理员、数据库管理员、网络打印机、可运行进程，如果定期备份数据库，此时的时间作为参与者

- 主要参与者：启动用例，系统必须响应主要参与者
- 次要参与者：可以参与到用例中
至少有一个参与者必须从用例中获得价值，通常这就是主要参与者

**参与者之间的关系**
1. 泛化关系：继承
2. 关联关系：一个参与者可以访问多个用例，一个用例可以被多个参与者访问

### 用例
用例是对一个参与者使用系统的一项功能时所进行的交互过程的一个文字描述序列，是参与者可以感受到的系统服务或功能单元

比如：图书馆中的用例有借书、还书、查找图书、借书证管理等

**用例的特征**
- 站在系统外部，看到系统的功能
- 总是被参与者启动
- 描述一个功能的交互场景
- 本质是一种功能分解技术
- 交互过程描述种可以发现类

#### **用例之间的关系**
**包含关系**
描述的是一个用例需要的功能被另外一个用例定义，基用例把被包含的用例行为作为自身行为的一部分
- 箭头方向由基用例指向被包含的用例，被包含的用例如果不存在了，基用例就不完整了
- 执行基用例时，每次都必须调用被包含的用例
- 被包含的用例也可以单独执行
![[Pasted image 20251227134856.png]]

**使用时机：**
1. 复用：如果两个以上用例有大量一致的功能，可以将一致的功能抽取到另一个用例，其他用例和这个用例建立包含关系
2. 功能分解：一个用例的功能太复杂时，将其功能分解为小功能用例

#### 扩展关系
基用例本身是一个完整用例，可以单独执行，执行基用例时，扩展用例不是每次都被执行
**扩展用例本身不是完整独立的用例，无法单独执行，必须依赖基用例**
![[Pasted image 20251227135645.png]]

UML 中提供了扩展点来为基用例扩展新行为，基用例中扩展点给出条件满足，则扩展用例将被执行

**区分包含关系和扩展关系**
包含用例必然被执行，扩展用例条件被执行

#### 泛化关系
同一业务目的不同技术实现
**用例之间可以泛化，参与者之间可以泛化**
父用例常常是抽象用例 ![[Pasted image 20251227140933.png]]

### 用例描述
针对每个用例，都应该有一个用例规约文档与之对应，文档描述参与者与系统交互实现用例功能的事件流
- 用例名称：表面用例用途
- 标识符（选）：唯一
- 参与者（选）：与此用例相关的参与者列表
- 简要说明：对用例说明，描述作用
- 前置条件：条件列表，描述用例之前系统必须满足条件，比如借书前置条件：借书证合法
- 后置条件：后置条件在用例成功后得到满足，它提供系统的部分描述，比如用例结束后系统处于什么状态
- 扩展点：写出扩展用例在什么条件下使用
- 基本事件流（主事件流）：描述正常进行时用例的工作方式
- 其他事件流（扩展事件、错误事件）：发生异常情况下的步骤
![[Pasted image 20251227143252.png]]

## 用例建模
### 用例建模流程
1. 获取原始需求：涉众（问卷、访谈、开会、原型...）
2. 开发一个可以理解的需求
	1. 识别参与者（在**系统之外**，透过系统边界与系统进行有意义的交互的**任何事物**，不在数量）----**责任类似或重叠，泛化出一个抽象执行者**
	2. 识别用例（执行动作后会生成特定执行者可见的**价值结果**）--要以用户观点而非系统观点 ![[Pasted image 20251227144312.png]]
		参与者视角：（状语）动词+（定语）宾语 ![[Pasted image 20251227144507.png]]
		------------------------------------------------------------------------------------------
	3. 绘制用例图 ![[Pasted image 20251227144541.png]]
3. 详细、完整描述需求
	1. 编写用例文档 (上述的文字方法或者活动图)
4. 重构用例模型
	1. 识别用例间关系
	2. 对用例进行分包和分级


## 用例建模常见问题
1. 参与者通过其他参与者使用系统的用例
2. 用例的包含关系和扩展关系区别
3. 系统边界
4. 用例模型的层次
5. 不同层次的用例模型的一致性

用例是因，功能是果
用例是目标，不是过程，是按照价值分解


# 第四章：静态建模
## 静态建模概述
UML 中，静态建模用以描述系统的组织和结构，而动态建模则用以描述系统的**行为**和**动作**，两者共同构件和描述系统的整体模型
## 类图
![[Pasted image 20251227153640.png]]
**类图的元素**
- 类
- 接口
- 依赖关系
- 泛化关系
- 关联关系
- 实现关系
- 聚合关系
- 组合关系
### 类图
类包括名称、属性部分、操作部分
**属性**：属性名称：属性类型（公有‘+’、私有‘-’、受保护‘#’）

**操作方法**：方法名 (参数名：参数类型=默认值, ...)

**作用域**：实例作用域下，类的不同实例有自己的属性值；分类作用域下，类的所有实例对象共享相同属性值（类似于静态属性），分类作用域的属性和操作下面要带下划线

**抽象类**：至少有一个抽象操作，在 UML 图中用斜体或者 `+drive(){abstract}` 表示

**接口**：是一组没有相应实现方法的描述，可以很好地将类所需要地行为于该行为如何实现完全分开，模型元素之间的协作通过接口实现

**接口和抽象类的区别**
1. 抽象类是一类事物的高度聚合，对于抽象子类来说，属于"是"的关系
2. 接口是定义行为规范，对于实现接口的子类来说，是"行为需要按照接口来完成"

### 类之间的关系
#### **关联**
当类之间在概念上有实例连接关系叫做关联，表明了两个对象之间的连接
![[Pasted image 20251227160637.png]]

**关联名**：简洁说明对象之间关系（拥有、WorkFor...），如果模型中存在相同类有多重关联，就必须要用关联名

**导航性**：
- 可以是单向，也可以是双向，箭头由源类指向目标类，表示源类的一个成员是目标类的对象 ![[Pasted image 20251227161206.png]]
- **双向关联**：两个类互相找得到对方 ![[Pasted image 20251227161322.png]]
- **自关联**：对象中的属性为对象本身 ![[Pasted image 20251227161416.png]]

**角色--关联端名**：当两个类发生关联时，每个类通常扮演着角色，角色名写在关联两端 ![[Pasted image 20251227161727.png]]
1. 模型存在多重关联，相同类之间多种不同联系，需要以关联名来消除歧义 ![[Pasted image 20251227161821.png]]
2. 对于自身反关联或者自身关联（同一类两个对象关联）![[Pasted image 20251227161858.png]]

**多重性**：某个类有多少个对象可以和另一个类的单个对象关联 ![[Pasted image 20251227162125.png]]

**关联上的约束**：关联上的多重性是集合基数上的约束，限制了于给定对象相关的对象数量
关联端上多侧对象常常没有明确顺序，可以看成集合，如果需要有顺序可以用 `{ordered}` 约束

**派生关联**：可以从其他关联计算推演得到的关联，派生关联名字前要加一个"/"、

**关联类**：和类一样，关联本身也有自己的属性和操作，它的可视化表示和类一样，但是要用虚线把关联类和对象关联线连起来 ![[Pasted image 20251227162733.png]]

#### 泛化
泛化关系是指一般元素和特殊元素的分类关系，泛化关系可用于类、用例、参与者以及其他模型元素，描述了一种 `is a kind of` 的关系，泛化关系可以传递
![[Pasted image 20251227170315.png]]

#### 聚合和组合
**聚合关系**：表示部分与整体之间的关系，描述"由... 构成、包含"![[Pasted image 20251227170450.png]]

关联关系和聚合关系不同点
- 聚合关系在代码上形似和关联类似
- 在关联关系上体现不出整体和部分的关系
- 聚合关系一定会体现整体和部分的关系

**组合关系**：是聚合关系的一种特殊形式，称强聚合，由两个额外约束
1. 一个部分至多属于一个整体，整体部分多重性为 1
2. 部分对象的生命周期取决于组合对象生命周期，部分类完全隶属整体类（翅膀和鸟）

#### 实现
类与接口的关系，表示类是接口所有特征和行为的实现 ![[Pasted image 20251227170851.png]]

#### 依赖
两个事物之间的语义关系，一个事物的改变会影响到另一个事物，可以视为耦合的另一个版本
1. 一个类是另一个类的方法参数
2. 一个类的方法中将另一个类的对象视为局部变量
3. 在一个类的方法调用另一个类的静态方法
![[Pasted image 20251227171125.png]]
![[Pasted image 20251227171137.png]]

### 类的版型
UML 中有 3 种主要的类版型，即边界类、控制类、实体类
#### 实体类
用于保存需要放进**持久存储体的信息**，实体类的对象是永久性的
实体类主要是作为数据管理和业务逻辑处理层面上存在的类别

#### 边界类
位于系统与外界的交界处，是系统内的对象和系统外的参与者的联系媒介，外界消息要通过边界类的对象实例才能发送给系统
- 窗口
- 对话框
- 报表
- 表示通讯协议的类（TCP/IP）
- ...
![[Pasted image 20251227171623.png]]

#### 控制类
主要用于封装系统的业务逻辑和控制流程，承担着协调系统中其他对象之间的交互的任务

**通常每个用例定义一个控制类**
![[Pasted image 20251227172040.png]]

**控制类-协调者对象**
做出总决策的对象，确定了相关对象集合的总体顺序安排。

#### 边界类、控制类、实体类协作
![[Pasted image 20251227172248.png]]
![[Pasted image 20251227172325.png]]

## 对象图
对象图实质上是具有关联关系的类图的实例
![[Pasted image 20251227174050.png]]

**类与对象的关系**
- 对象是一个存在于时间和空间的实体，类仅代表一种抽象，抽象出对象的本质
- 类是静态的，对象是动态的
- 类是一般化，对象是个性化
- 类是定义，对象是实例
- 类是抽象，对象是具体

对象图描述的是参与交互的各个对象在交互过程中某一时刻的状态，它是**系统在某一个特定时间点上的静态结构**，是类和实体的快照
对象图所建立的对象模型描述的是**某种特定的情况**，而类图所建立的模型描述的是**通用的情况**

| 类图                             | 对象图                                |
| ------------------------------ | ---------------------------------- |
| 在类图中，每个类包含三部分：类名、类的属性和类的操作     | 每个对象包含二部分：对象名、对象属性                 |
| 类的名称栏只包含类名                     | 对象的名称栏包含对象名和类名                     |
| 类的属性栏定义了所有属性的特征                | 对象的属性栏定义了属性的当前值                    |
| 类中列出了操作                        | 对象图中的对象不包含操作，因为对于属于同一个类的对象，其操作是相同的 |
| 类中使用了关联连接，关联中使用关联名、角色以及约束等特征定义 | 对象使用链进行连接，链中包含名称、角色                |
| 类是对象的抽象                        | 对象是客观存在的抽象，对象是类的实例                 |
 
#### 对象图建模
1. 识别相关的类、接口和其他元素之间的关系
2. 针对某个场景，在特定时刻冻结，识别相关对象
3. 描述对象的状态和属性值
4. 描述对象之间的链接

## 静态建模步骤
1. 研究分析问题领域, 确定系统需求
2. 确定类, 明确类的含义和职责, 确定属性和操作
3. 确定类之间的关系
4. 调整和细化类及类之间的关系
5. 绘制类图并增加相应的说明
6. 根据类图，生成系统某一时刻的对象图

# 第五章：动态建模
## 动态建模概述
UML 中，静态建模用以描述系统的组织和结构，而动态建模则用以描述系统的行为和动作。包括 4 类图：顺序图、协作图、状态图、活动图
- 顺序图：交互图，主要描述对象之间动态合作关系以及合作过程的行为次序，常用来描述一个用例的行为
- 协作图：用于描述相互合作的对象间的交互关系，它描述的交互关系是对象间的消息连接关系
- 状态图：描述对象、子系统、系统的生命周期
- 活动图：着重描述操作实现中完成的工作以及用例实例或对象中的活动，活动图是状态图的一个变种
### 对象交互行为模型
顺序图和协作图，通常描述一个用例或者部分用例行为，显示该用例中所涉及的对象和消息传递情况 ![[Pasted image 20251227193149.png]]
![[Pasted image 20251227193201.png]]
### 对象状态模型
状态图：为某个用例创建时间发生的轨迹，说明对象状态迁移变化的顺序 ![[Pasted image 20251227193305.png]]

### 对象活动模型
活动图：描述事件的活动是并发的还是顺序的 ![[Pasted image 20251227193345.png]]

## 顺序图
### 概述
顺序图也称时序图，描述**对象**之间按时间顺序进行的消息交互过程
顺序图用来描述**一个用例的执行**。消息的交互顺序可以和用例描述的流程进行相互印证，从而判断用例行为是否已经分解到对象及方法上了
- **对象**：对象、对象的生命线、对象的执行发生和对象的删除
- **消息**：简单消息、同步消息、异步消息、返回消息

比如用户登录界面
![[Pasted image 20251227195007.png]]
### 顺序图的元素
#### 对象
**命名方式**
1. 包括对象名和类名
2. 类名（匿名对象）
3. 对象名（不关心类）
如果对象的位置不在顶部，那就说明对象是在交互中创建的；如果在顶部，那就说明开始时已经存在 ![[Pasted image 20251227195336.png]]

#### 生命线
每个对象都有自己的生命线，在图中是一条向下延申的虚线，表示对象在特定时间存在 ![[Pasted image 20251227195753.png]]

#### 激活期
激活表示该对象被占用以完成某个任务，对象执行某个动作的时期
去激活指对象处于空闲状态，不做事情但是存在，等新的消息去激活它
在 UML 图中，用长矩形表示激活状态 ![[Pasted image 20251227200322.png]]
激活表示行为执行的持续时间，也可以表示活动和它调用者之间的关系

#### 消息
- 消息是对象之间以某种形式通信，可以激发某个操作、发送信号或导致目标对象的创建或撤销
- 消息是两个对象间的**单路通信**，从源对象指向目标对象，以触发**目标对象的特定操作**
- 消息可用于对象间传递参数
- 可以是信号（对象间异步通信），也可以是调用（具有返回控制机制的同步调用）
在 UML 中，箭头的类型表示了消息的类型
**UML 三种消息**
1. 调用消息
2. 异步消息
3. 返回消息

**调用消息**（实线实心箭头）
发送者把控制信息传给消息接收者，然后停止活动，等待接收者执行某种操作后返回控制
由于**发送者等待接收者**，这种消息又叫**同步消息**；通常，同步消息会隐含包含了来自接收者的一个返回消息
![[Pasted image 20251227201320.png]]
**异步消息**（实线箭头）
消息发送后，发送者继续操作，不等待，常用于并发 ![[Pasted image 20251227201450.png]]
![[Pasted image 20251227201514.png]]
**返回**（虚线箭头）
一般同步过程的返回不需要画出，直接隐含，而异步返回则要用

**发给自身的消息（反身消息）**
反身消息一般是同步消息 ![[Pasted image 20251227201840.png]]

**Rose 消息**
- 阻止消息：如果接收者无法立即接收消息，则放弃发这个消息（折回箭头）![[Pasted image 20251227202011.png]]
- 超时消息：如果接收者无法在指定时间内接收消息，则放弃这个消息

### 顺序图的组合交互
现实业务不可能按照一条路走完，总会有特殊情况，这时候需要用到组合框来表示特殊情况，比如循环、分支、并行等

#### 常用的交互片段对于的操作符及作用
![[Pasted image 20251227203441.png]]
#### Ref 交互
为一个用例的多个场景创建实例顺序图，图和图之间有部分重复的，ref 交互片段能在一张顺序图中快速复用另一张顺序图中重复的部分
使用方法：使用 ref 交互片段并写明要引用的交互图名称 ![[Pasted image 20251227203827.png]]
#### Loop 交互
表示该片段内的交互被循环执行多次，而具体次数由循环次数和监护条件表达式来说明（监护条件为真执行）
Loop (minint, maxint)
Minint 表示循环最小次数，Maxint 表示最大次数
![[Pasted image 20251227204247.png]]
#### Opt 和 alt 交互（表分支）
分支：表明交互的控制流程取决于某个特定条件
单条件分支（opt）和多条件分支（alt）
**opt 交互**
在判断条件为真时才执行 ![[Pasted image 20251227210238.png]]
**alt 交互**
有多个区域，不同区域用虚线分割，每个区域一个监护条件，代表一个分支，根据判断条件，选择一个区域交互 ![[Pasted image 20251227210355.png]]
#### Par 交互
每个区域交互并发工作而不会互相交互 ![[Pasted image 20251227210444.png]]

#### 交互片段嵌套
![[Pasted image 20251227210536.png]]
#### Break 交互
和循环语句中 break 类似，用 break 定义一个含有监护条件的子片段 ![[Pasted image 20251227210642.png]]
#### Critical 交互
 表示子片段是临界区域，在临界区域中，生命线上的事件序列不能和其他区域中任何其他事交错
 ![[Pasted image 20251227210841.png]]
 **临界区域是一段必须原子执行的代码，不能被中断；不能被交错执行；不能被其他线程/进程同时访问**
### 顺序图建模
1. 确定要建模的用例
2. 确定用例的工作流
3. 确定工作流涉及的对象
4. 在顺序图中添加消息和条件以创建每个工作流
在系统设计阶段，可以细分出边界类、控制类和实体类

## 协作图
### 概述
描述了一组对象为实线某目的而组成互相合作的"对象社会"，表示了协作中各种类元对象所处的位置
协作图将**类元角色**表示为类元符号表示为矩形框，将**关联角色**表现为实线的关联路径，关联路径上有消息符号
协作图强调的是**空间**，通过链接显示对象于对象之间如何联系 ![[Pasted image 20251227213030.png]]
#### 协作图的作用
1. 同过描绘对象之间的消息的传递情况来反映逻辑表达
2. 显示对象及其交互关系的空间组织结构
3. 表现一个类操作的实现

### 协作图的元素
1. 对象
2. 链
3. 消息
#### 对象
和顺序图中对象概念相同，只是对象在图中的位置没有限制
![[Pasted image 20251227213411.png]]
同一个类的对象在一个协作图中可能要担任多个角色

**多对象（多重对象）**
一系列同类实例，如果消息同时发给多个同类对象，则可用多重对象表示
![[Pasted image 20251227213643.png]]
**消息前面要加" * "号**，表示循环

#### 链
表示对象之间的语义连接，必须先有对象之间的链，才能建立两个对象之间的交互
**绘制方式与对象图中一样，含义也一样**

#### 消息
消息用来描述系统的动态行为，体现类的调用和实现
一个链上可附有多条消息，每个消息包括一个信息的编号和名称，还可以包含参数、返回值类型等

**消息的语法格式**
![[Pasted image 20251227214249.png]]
`[前缀][监护条件][消息顺序表达式][返回值:=]消息名([参数列表])`
![[Pasted image 20251227214646.png]]

**并发消息**
两个相同对象之间存在多个消息，这些消息可以同时调用，即并发消息 ![[Pasted image 20251227214845.png]]

**返回结果**
UML 提供了返回值的表示法 `:=` 接着是操作名和操作参数
比如 `totalPrice:=compute(itemPrice,salesTax)`

### 协作图的建模步骤
1. 确定要建模的用例
2. 确定用例的工作流
3. 确定各工作流涉及的对象
4. 在协作图中添加带编号的消息和条件以便创作每个工作流

### 协作图与顺序图关系
一个单独协作图/顺序图只描述一个事件流

- 协作图和顺序图一样，都是展示对象之间交互，属于交互图
- 协作图和顺序图在语义上是等价的，有些建模工具可以将此两种图进行等价转换

**区别**
1. 顺序图强调消息事件顺序，协作图强调对象空间位置关系
2. 顺序图中有对象生命线和控制焦点；协作图中有路径，消息必须要有消息序号
3. 顺序图可以表示生命线的分叉；协作图可以表示多对象、主动对象

## 状态图
状态图用来描述一个特定的对象所有可能的状态，以及由于各种事件的发生而引起的状态之间的转移和变化 
### 概述
实例：java 线程状态
![[Pasted image 20251227220959.png]]
一般系统中，不需要对每个类创建状态图
实体的生存期比较复杂时，需要状态图来建模（类实例有多种状态，每种状态的行为表现不相同）

顺序图和状态图是动态行为互补的视图
- 顺序图显示了较短时间内系统对象传递消息，因此要描述**很多对象**
- 状态图自始至终在一个**单一对象**生存周期跟踪该对象

### 状态图的组成
1. 状态
2. 转移
3. 事件（触发转移）
4. 动作
5. 活动
![[Pasted image 20251227221828.png]]

#### 状态
用于描述一个对象生命周期内一个时间段的状况
对象的状态是指在特定时间点上所处的条件或属性集合
- 初始状态（初态）：一个状态机只能有一个初态，嵌套可以使用新的初态
- 终止状态（终态）：一个状态机可以有 1、0、n 个终态，嵌套状态可以使用新的终态
- 中间状态
	- 状态名
	- 出入口动作
	- 内部活动：不导致当前状态发生改变的活动或者动作
	- 内部事件：不导致当前状态改变的事件，会触发相应内部动作
	- 延迟事件：延迟到下一状态中处理的事件
#### **组合状态**
一个状态内嵌套了若干状态，被嵌套的状态称为子状态 ![[Pasted image 20251227223108.png]]
1. 顺序子状态：or 关系分解为互相排斥的顺序子状态
2. 并发子状态：and 关系分解为并发子状态
**顺序子状态**
任何时刻只能处于一个子状态，状态间互斥
![[Pasted image 20251227223314.png]]
**并发子状态**
组合状态有两个或者多个并发的子状态机 ![[Pasted image 20251227223417.png]]

**历史状态**
当离开一个组合状态重新进入此状态，不希望从初始状态开始，而是离开时的最后一个子状态，用包含字母"H"的圆圈表示
如果是嵌套深的历史状态，就用"H*"表示

#### 转换
一个事件导致对象从一个状态转移到另一个状态称为转移
需要条件的转移叫触发转移
不需要条件的转移叫无触发转移
![[Pasted image 20251227224208.png]]

**状态转换五要素**
1. 源状态
2. 目标状态
3. 触发事件
4. 监护条件
5. 动作

监护条件只在发生事件时计算依次，如果转移被重新触发，则监护条件要再次被计算

转换种类：外部转换、自转换、内部转换、复合转换
**自转移**
源状态和目标状态相同的转移，但它是状态改变
![[Pasted image 20251227225326.png]]
**内部转换**
内部转换自始至终都不离开本状态，没有出入口事件，不执行出入口动作

**复合转移--并发与同步**
同步：在并发中同步，并发状态之间需要通信，或具有确定的时序关系，称为并发中的同步
定义了并发工作流的分劈（fork）和接合（join）
- 分劈是一个源状态分成两个或者两个以上的目标状态
- 接合是两个以上的源状态连接为一个目标状态
- 同步在状态图中用一条粗短线表示，称为**同步杆**
![[Pasted image 20251227225911.png]]

#### 事件
**事件是对一个时间和空间上具有一定意义的事情的规格说明**
**事件的类型**
- 调用事件
- 信号事件
- 变化事件
- 时间事件

**调用事件**
对某对象成员方法的调用，是一种同步机制
事件触发转移后，接收者 B 转到一个新的状态，还会将控制返回给发送者 A ![[Pasted image 20251228083753.png]]

**信号事件**
一个对象异步地发送并由另一个对象接收地一个已命名的对象，信号可以作为状态转换的动作被发送，也可以作为交互消息被发送

**变化事件**
如果布尔表达式中的变量变化，使得该表达式值也变化，而满足条件，叫做变化事件
用了关键字 `when`, 后面跟布尔表达式
变化事件隐含了对控制条件的连续测试，当条件从假变成真，事件发生。类似于编程语言中的循环（循环终止是条件变成假）

**与监护条件区别，监护条件在相关事件出现后才计算一次，而变化事件会不断被测试**

**时间事件**
满足某一时间表达式，关键字为 `when` `after`
![[Pasted image 20251228084329.png]]

**延迟事件**
本状态不处理，留到另一个状态处理，关键字为 defer
`延迟事件/defer`

#### 动作
对象为了响应事件要做哪些工作
- 动作是一组可执行语句或者计算处理过程
- 整个系统可以在同一时间执行多个动作
- 动作分为**外部动作**和**内部动作**

### 状态图的建模
1. 找出合适的模型描述其行为的类
2. 确定对象可能存在的状态，找出状态属性
3. 确定引起转换的事件
4. 确定转换进行时对象执行的响应操作
5. 对建模结果进行相应精细化（组合状态、子状态、并发子状态、顺序子状态、历史状态、分支等）

## 活动图
### 概述
活动图是一种用来描述系统或流程中的活动、动作和交互的图表，用于分析和设计软件系统、业务流程和交互
**绘制场景**：
1. 用例场景：用户执行操作和交互流程
2. 业务流程
3. 系统流程

**活动图本质是一种流程图**

### 活动图元素
活动图描述系统工作流程和并发行为，每个活动代表一个操作步骤
1. 初始节点和终点
2. 活动
	1. 活动状态
	2. 动作状态
3. 动作流
4. 分支与合并
5. 分支与汇合
6. 泳道
7. 对象流
#### 初始节点和终点
用一个实心圆形表示初始节点，用一个圆圈加一个实心圆形表示活动终点
活动图中包含多个终点，但有且仅有一个起始点

#### 活动
通常是指系统、用户或者其他参与者执行的任务或操作
- 基本活动
- 业务活动
- 调用行为