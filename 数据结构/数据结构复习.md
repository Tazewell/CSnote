## 1、2 章
- 与所使用计算机无关的是数据的逻辑结构
- 链式存储结构所占存储空间分两部分，一部分存放结点值，另一部分存放表示结点之间关系的指针
- 时间复杂度计算：求 k（循环执行次数）
- 顺序表：数组实现，可以实现随机访问，复杂度为 O (1)
- 删除一个元素移动的平均个数是求期望 ```E=p*A```
- 顺序存储表示中数据元素之间的逻辑关系是由**存储位置**表示的
## 3、4 章
- 循环队列队满条件：```(rear+1)%MAXSIZE == front```
- 循环队列出队操作：```front = (front+1)%MAXSIZE```
- 循环队列入队操作：```rear = (rear+1)%MAXSIZE```
**链队列**
```cpp
#include<iostream>
using namespace std;

#define OK 1

#define ERROR 0
typedef int Status;
typedef char QElemType;
typedef struct QNode{
    QElemType data;

    struct QNode *next;

}QNode, *QueuePtr;

typedef struct {
    QueuePtr front;
    QueuePtr rear;
} LinkQueue;  

Status InitQueue(LinkQueue &Q){
    Q.front = Q.rear = new QNode;
    Q.front->next = NULL;
    return OK;
}
Status EnQueue(LinkQueue &Q, QElemType e){
    QueuePtr p;
    p = new QNode;
    p->data = e;
    p->next = NULL;
    Q.rear->next = p;
    Q.rear = p;
    return OK;
}
Status DeQueue(LinkQueue &Q, QElemType &e){

    QueuePtr p;

    if (Q.front == Q.rear){
        return ERROR;
    }
    p = new QNode;
    p = Q.front->next;
    e = p->data;
    Q.front->next = p->next;
    if(Q.rear == p){
        Q.rear = Q.front;
    }
    delete p;
    return OK;
}
int main(){

    LinkQueue Q;
    int n, m, i;
    char c;
    InitQueue(Q);
    cin >> n;
    for (i=0; i<n; i++){
        cin >> c;
        EnQueue(Q, c);
    }
    return 0;
}
```
模式匹配算法
```cpp
#include<cstring>
#include<iostream>
using namespace std;

#define OK 1
#define ERROR 0
#define OVERFLOW -2
typedef int Status;
#define MAXSTRLEN 255
typedef char SString[MAXSTRLEN+1];

int Idnex(SString S, SString T, int loc){
    int i = loc;
    int j = 1;
    while(i<=S[0] && j<=T[0]){
        if(S[i] == T[j]){
            i++;
            j++;
        }
        else{
            i = i-j+2;
            j = 1;
        }
    }
    if(j>T[0]){
        return i-T[0];
    }else{
        return 0;
    }
}
```
顺序栈基本操作
```cpp
typedef struct { 
	SElemType *base;
	SElemType *top;
	int stacksize; 
}Sqstack;

Status iniStack(Sqstack &S){
    S.base = new SElemType[stack_INIT_SIZE];
    if(!S.base) return ERROR;
    S.top = S.base;
    S.stacksize = stack_INIT_SIZE;
    return OK;
}
Status push(Sqstack &S,SElemType x){
    if(S.top - S.base == S.stacksize){
        return ERROR;
    }
    *S.top = x;
    S.top++;
    return OK;
}
Status pop(Sqstack &S,SElemType &e){
    if(S.top == S.base){
        return ERROR;
    }
    e = *S.top;
    S.top--;
    return OK;
}
```
循环队列基本操作
```c
typedef struct {
  int *base;
  int front;
  int rear;
}SqQueue;
void InitQ(SqQueue &Q,int N){
    Q.base = (int*)malloc(sizeof(int)*N);
    Q.front = Q.rear = 0;
}
void AddQ(SqQueue &Q, int x ){
    if((Q.rear+1)%N==Q.front){
        printf("Queue Full\n");
        return;
    }
    Q.base[Q.rear] = x;
    Q.rear = (Q.rear+1)%N;
}
Status DeleteQ(SqQueue &Q,int &e){
    if(Q.rear == Q.front){
        printf("Queue Empty\n");
        return 0;
    }
    e = Q.base[Q.front];
    Q.front = (Q.front+1)%N;
    return 1;
}
```
用栈进行进制转换
```c
Status iniStack(Sqstack &S){
    S.base = (SElemType*)malloc(sizeof(SElemType)*stack_INIT_SIZE);
    if(!S.base) return ERROR;
    S.top = S.base;
    S.stacksize = stack_INIT_SIZE;
    return OK;
}
Status push(Sqstack &S,SElemType x){
    if(S.top - S.base >= S.stacksize){
        SElemType *newbase = (SElemType *)realloc(S.base, (S.stacksize + stackINCREMENT) * sizeof(SElemType));
        if (!newbase) return OVERFLOW;
        S.base = newbase;
        S.top = S.base + S.stacksize;
        S.stacksize += stackINCREMENT;
    }
    *S.top = x;
    S.top++;
    return OK;
}
Status pop(Sqstack &S,SElemType &e){
    if(S.top == S.base) return ERROR;
    e = *S.top;
    S.top--;
    return OK;
}
void conversion(int n,int R){
    iniStack(S);
    if(n==0){
        return ERROR;
    }else{
        while(n!=0){
            int r = n%R;
            push(S, r);
            n = n/R;
        }
        SElemType e;
        while(pop(S, e)==OK){
            print("%d",e);
        }
    }
}
```
链队列
```c
Status InitLinkQueue(LinkQueue &Q){
    Q.front = Q.rear = NULL;
    return OK;
}
Status EnLinkQueue(LinkQueue &Q,QElemType e){
    QueuePtr V = (QueuePtr)malloc(sizeof(QNode));
    V->data = e;
    V->next = NULL;
    if(Q.front==NULL && Q.rear==NULL){
        Q.front = (QueuePtr)malloc(sizeof(QNode));
        Q.front = V;
        Q.rear = V;
        return OK;
    }
    Q.rear->next = V;
    Q.rear = V;
    return OK;
}
Status DeLinkQueue(LinkQueue &Q,QElemType &e){
    if(Q.front == NULL){
        return ERROR;
    }
    e = Q.front->data;
    QueuePtr p = Q.front;
    Q.front = p->next;
    free(p);
    return OK;
}
Status QueueEmpty(LinkQueue Q){
    if(!Q.front && !Q.rear){
        return FALSE;
    }
    else{
        return TRUE;
    }
}
```
## 5 章
树的深度或者高度：根节点算第一层
二叉树在第 i 层上最多有 2^(i-1) 个结点
深度为 k 的二叉树最多有 2^k -1 个结点
满二叉树：深度为 k, 切有 2^k-1 个结点的二叉树
完全二叉树：深度为 k，有 n 个结点的二叉树，结点从左到右排，不间断
具有 n 个结点二点完全二叉树深度为 log 2 (n) +1 向下取整
遍历二叉树
- 先序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中
中序遍历递归
```c
void InorderTraverse(BiTree T){
	if(T){
		InoderTraverse(T->lchild);
		cout<<T->data<<'';
		InorderTraverse(T->rchild);
	}
}
```
已知二叉树先序和中序或者中序和后序可以得到二叉树
先序遍历建立二叉树
```c
void CreateBiTree(BiTree &T){
	cin>>ch;
	if(ch=='#'){
		T=NULL;
	}else{
		T=new BiTNode;
		T->data = ch;
		CreateBiTree(T->lchild);
		CreateBiTree(T->rchild);
	}
}
```
计算二叉树深度
```c
int Depth(BiTree T){
	if(T==NULL){
		return 0;
	}else{
		m = Depth(T->lchild);
		n = Depth(T->rchild);
		if(m>n){
			return m+1;
		}else{
			return n+1;
		}
	}
}
```
树的存储结构
1. 双亲表示法

| Data | Parent |
| ---- | ------ |
2. 孩子表示法

| Data | Child 1 | Child 2 | Child 3 |
| ---- | ------- | ------- | ------- |
森林和二叉树转换
1. 树转二叉树
	1. 给兄弟之间加线
	2. 给除长子外的孩子去线
	3. 层次调整（由兄弟转换成的长子都是右节点，第一个孩子是左节点）
2. 森林转二叉树
	1. 森林中每棵树转化为二叉树
	2. 将第二棵树的根节点作为第一棵树的右孩子，将第三个树作为第二棵树的右孩子
3. 二叉树转化成树
	1. 如果一个节点左孩子存在，则左孩子的右孩子和右孩子的右孩子都与该节点结点连接
	2. 去除与右孩子之间的连线
4. 二叉树转森林（二叉树根节点必须有右孩子）
	1. 寻找根节点右孩子，去除其间连线
	2. 查看分离的二叉树如果也有右孩子则重复操作
	3. 再二叉树转树

### 哈夫曼树
路径：从一个结点到另一个结点之间的分支构成这两个结点之间的路径
路径长度：分支数目
树的路径长度：从树根到每一结点的路径长度之和
权
结点的带权路径长度：该节点到树根之间路径长度与结点上权的乘积
树的带权路径长度：树中所有叶子结点的带权路径长度之和
构造哈夫曼树
1. 权值越大离根结点越近
2. 权值越小离根节点越远
- 在一个集合里选取权值最小的两颗二叉树，作为左右子树构造一棵新的二叉树
- 新二叉树放进集合，再删除上一步的两颗二叉树
- 重复上面步骤，直到剩一棵树（n 个结点会重复步骤 n-1 次）
哈夫曼树没有度为一的结点
有 $n0$ 个叶子结点的哈夫曼树，有 $2n0 - 1$ 个结点
### 哈夫曼编码
哈夫曼树中左分支为 0 右分支为 1，从根节点到每个叶结点所经过的分支对应的 01 组成的序列便是该结点对应字符的编码
![[Pasted image 20251212165318.png]]
不等长编码，权值越大说明出现频率越高
**在一组字符的哈夫曼编码中，不可能出现一个字符的哈夫曼编码是另一个字符哈夫曼编码的前缀**
构建哈夫曼编码
```c
typedef struct{
    int weight;
    int parent, lchild, rchild;
}HTNode, *HuffumanTree;

  

void CreateHuffmanTree(HuffmanTree &HT, int n){

    if(n<1){
        return;
    }

    m = 2*n - 1;
    HT = new HTNode[m+1];

    for(i=1; i<=m; i++){
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
    }
    for(i=1; i<=n; i++){
        cin>>HT[i].weight;
    }
    for(i = n+1; i<=m; i++){
        Select(HT, i-1, s1, s2);//在HT中选择两个其双亲为0，权值最小的两个结点，并返回他们的序号s1和s2
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
}
```
### 平衡二叉树
- **它必须先是一棵二叉排序树**：即对于任意节点，左子树所有节点的值 < 根节点 < 右子树所有节点的值。
- **高度平衡**：对于树中的**任意一个节点**，其左子树和右子树的**高度之差（绝对值）不超过 1**。
通过旋转来解决
1. 左旋：冲突的左孩变成右孩
2. 右旋：冲突的右孩变左孩
![[Pasted image 20251212190124.png]]
